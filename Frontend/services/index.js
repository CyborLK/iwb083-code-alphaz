import jwt from "jsonwebtoken";
const SERVICE_SERVER_URL = process.env.SERVICE_SERVER_URL || "http://localhost:8080";

export var socket = new WebSocket(null);

export class WebSocketTrigger {
	/**
	 * Event handler for when the WebSocket connection is established.
	 * @param {function} callback - Called when the WebSocket connection is established.
	 * @example
	 * const wsTrigger = new WebSocketTrigger();
	 * wsTrigger.onOpen((event) => {
	 *     console.log("WebSocket connection established.");
	 * });
	 */
	onOpen(callback) {
		socket.addEventListener("open", (event) => {
			callback(event);
		});
	}

	/**
	 * Event handler for when the WebSocket connection receives a message.
	 * @param {function} callback - Called when the WebSocket connection receives a message.
	 * @example
	 * const wsTrigger = new WebSocketTrigger();
	 * wsTrigger.onMessage((message) => {
	 *     console.log(`Received message: ${message}`);
	 * });
	 */
	onMessage(callback) {
		socket.addEventListener("message", (event) => {
			callback(event.data);
		});
	}


	/**
	 * Event handler for when the WebSocket connection is closed.
	 * @param {function} callback - Called when the WebSocket connection is closed.
	 * @example
	 * const wsTrigger = new WebSocketTrigger();
	 * wsTrigger.onClose((event) => {
	 *     console.log("WebSocket connection closed.");
	 * });
	 */
	onClose(callback) {
		socket.addEventListener("close", (event) => {
			callback(event);
		});
	}

	/**
	 * Event handler for when the WebSocket connection encounters an error.
	 * @param {function} callback - Called when the WebSocket connection encounters an error.
	 * @example
	 * const wsTrigger = new WebSocketTrigger();
	 * wsTrigger.onError((error) => {
	 *     console.error(`WebSocket error: ${error}`);
	 * });
	 */
	onError(callback) {
		socket.addEventListener("error", (event) => {
			callback(event);
		});
	}
}

export const serverAuthorization = async () => {
	const response = await fetch(`${process.env.SERVICE_SERVER_URL}/authorize`, {
		method: "GET",
		headers: {
			"Content-Type": "application/json",
			"Authorization": "Bearer " + jwTokensGenerator()
		}
	});

	return {
		serverAthorization: {
			code: response.status,
			accepted: response.statusText === "Accepted",
			aliveToken: response.headers.get("keep-alive-token") || null
		},
		serverResponse: response
	};
}

const jwTokensGenerator = (credentials) => {
	const jwToken = jwt.sign(credentials ? credentials : {}, process.env.JWT_SECRET);

	return jwToken;
}

// User should authorized by the server with the token before accessing further server actions:nivindulakshitha
const serverAuth = await serverAuthorization();

// After server authorization user can request other actions with retrieved token which is generated by the server:nivindulakshitha
if (serverAuth.serverAthorization.accepted) {
	fetch(`${process.env.SERVICE_SERVER_URL}/auth/login`, {
		method: "POST",
		headers: {
			"Content-Type": "application/json",
			"keep-alive-token": serverAuth.serverAthorization.aliveToken // server generated keep-alive-token should be provided with every request:nivindulakshitha
		},
		body: JSON.stringify({ // Credentials for login request:nivindulakshitha
			email: "admin@localhost",
			password: "admin",
		})
	}).then(response => {
		if (response.status === 202) {
			console.log("Login successful.");
		} else {
			console.log("Login failed because,", response.statusText); // Fail reason can be accessed from response, can be used to present to user:nivindulakshitha
		}
	}).catch(error => {
		console.log(error);
	});
}